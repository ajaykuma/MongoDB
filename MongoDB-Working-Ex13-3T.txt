Aggregations:
Operators come in three varieties: stages, expressions, and accumulators.

When calling aggregate on a collection, we pass a list of stage operators. 
Documents are processed through the stages in sequence, with each stage applying to each document individually. 
Most importantly remember, that aggregation is a “pipeline” and is just exactly that, being “piped” processes 
that feed input into the each stage as it goes along. 
The output from the first thing goes to the next thing and then that manipulates 
to give input to the next thing and so on.

For example:
we'll simply stick to 3 main data entities:

A Customer, which represents a person taking a service/device
A Product, which represents a service/device
A Transaction, which represents the number of services/devices customer took.

Typical customer entity:
{
  "id": "1",
  "firstName": "Jane",
  "lastName": "Doe",
  "phoneNumber": "555-555-1212",
  "email": "Jane.Doe@test.io"
}

we'll need to determine what types of validations we'd like to do on this entity.

We can validate any of the fields in a collection and can validate based on the existence of a field, 
data type and format in that field, values in a field, and correlations between two fields in a document.

In the case of the Customer entity, we'd like to validate the following:

firstName, lastName, phoneNumber and email are all required to exist
phoneNumber is inserted in a specific format (123-456-7890)
email exists (we won't validate email format for now)
We can represent these validations in an intermediate format (before putting them into the database) 
using the JSONSchema spec. 
While JSONSchema isn't a necessary step to do validations in MongoDB, it's helpful to codifying our rules in a 
standard format and JSONSchema is quickly gaining traction for doing server-side validations.

For customer entity:

{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "id": {
      "type": "string"
    },
    "firstName": {
      "type": "string"
    },
    "lastName": {
      "type": "string"
    },
    "phoneNumber": {
      "type": "string",
      "pattern": "^([0-9]{3}-[0-9]{3}-[0-9]{4}$"
    },
    "email": {
      "type": "string"
    }
  },
  "required": [
    "id",
    "firstName",
    "lastName",
    "phoneNumber",
    "email"
  ]
}


Note**Using JSONSchema also allows us to re-use validations on the application side as well, 
such as RESTHeart's JSONSchema validation.

Typical product entity:
{
  "id": "1",
  "name": "Router",
  "listPrice": 20.99,
  "sku": 555555555,
  "productId": "123abc"
}

{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "id": {
      "type": "string"
    },
    "name": {
      "type": "string"
    },
    "listPrice": {
      "type": "number"
    },
    "sku": {
      "type": "integer"
    },
    "productId": {
      "type": "string"
    }
  },
  "required": [
    "id",
    "name",
    "listPrice",
    "sku",
    "productId"
  ]
}

Typical transaction entity:
{
  "id": "1",
  "productId": "1",
  "customerId": "1",
  "amount": 41.98
}

Validation rule:
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "type": "object",
  "properties": {
    "id": {
      "type": "string"
    },
    "productId": {
      "type": "string"
    },
    "customerId": {
      "type": "string"
    },
    "amount": {
      "type": "number"
    }
  },
  "required": [
    "id",
    "productId",
    "customerId",
    "amount"
  ]
}

#Create collections:
db.createCollection("customers", {
  validator: {
    $and: [
      {
        "firstName": {$type: "string", $exists: true}
      },
      {
        "lastName": { $type: "string", $exists: true}      
      },
      {
        "phoneNumber": { 
          $type: "string", 
          $exists: true,
          $regex: /^[0-9]{3}-[0-9]{3}-[0-9]{4}$/
        }
      },
      {
        "email": {
          $type: "string",
          $exists: true
        }
      }
    ]
  }
})

db.createCollection("products", {
  validator: {
    $and: [
      {
        "name": {$type: "string", $exists: true}
      },
      {
        "listPrice": { $type: "double", $exists: true}      
      },
      {
        "sku": { $type: "int", $exists: true}
      }
    ]
  }
})

db.createCollection("transactions", {  
  validator: {
    $and: [
      {
        "productId": {$type: "objectId", $exists: true}
      },
      {
        "customerId": { $type: "objectId", $exists: true}      
      },
      {
        "amount": { $type: "double", $exists: true}
      }
    ]
  }
})

#Testing validations
db.customers.insertOne({  
  firstName: "John",
  lastName: "O'Connor",
  phoneNumber: "555-555-1212"
});

since we omitted email, this will fail with "errmsg" : "Document failed validation"

db.customers.insertOne({ 
    firstName: "John", 
    lastName: "O'Connor", 
    phoneNumber: "555-555-1212", 
    email: "john@test.io"
    });

#keep a track of insertID after insert

db.products.insertOne({  
  name: "Router",
  listPrice: 20.99,
  sku: 1
});


#keep a track of insertID after insert

db.transactions.insertOne({  
  productId: ObjectId("xxxxxxxxx"),
  customerId: ObjectId("yyyyyy"),
  amount: 2.99
});

check ur collections
-------------------------------
